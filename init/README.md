# 内核启动与初始化

## 物理内存布局和内核页表

我们通过 QEMU/Bochs 模拟一个物理内存大小为 32MB 的计算机. 使用 Grub 作为引导程序, 其完成物理内存区域等硬件情况的检查, 并将该结果保存在内存的某个位置, 并将指向该内存地址的指针保存在 `ebx` 寄存器中. 在我们的内核启动代码中, 只需读取该地址处的内容, 即可得到机器的物理内存区域情况:

|序号|起始地址|长度|可用/保留|
|:-:|:-:|:-:|:-:|
|1|0x00000000|0x0009FC00|可用|
|2|0x0009FC00|0x00000400|保留|
|3|0x000F0000|0x00010000|保留|
|4|0x00100000|0x01EE0000|可用|
|5|0x01FE0000|0x00020000|保留|

通过链接脚本, 我们使内核的内存布局如下表所示, 内核被载入到物理内存 1MB 开始的位置, 其中 `.init` 段的物理地址和线性地址保持一致, 因为执行这段代码时还未进行内核页表的初始化. `.init` 段之后的段都通过二级页表映射到 3GB 以上的地址空间中. 具体的内存分布如下表所示:

|序号|段名|起始物理地址|起始线性地址|长度|可写|可执行|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|.init|0x00100000|0x00100000|0x1000|-|-|
|2|.text|0x00101000|0xC0101000|0x7000|-|X|
|3|.rodata|0x00108000|0xC0108000|0x1000|-|-|
|4|.data|0x00109000|0xC0109000|0x1000|W|-|
|5|.bss|0x0010a000|0xC010a000|0x2e000|W|-|

`.init` 段中包含了 Grub 引导程序结束后执行的第一段内核代码, 这段代码位于文件 `boot/boot.s` 中. 根据 Grub 规范, 我们需要在代码开始处存放 3 个魔数, 之后的代码完成内核页表的初步设置, 接着初始化堆栈并跳转到 C 程序执行. 关于保护模式相关的内容, 已经由 Grub 完成设置, 后续我们只需再修改全局描述符表即可.

我们将内核页目录表保存在内存的第 0 号页框中, 而 8 张页表则保存在第 1-8 号页框中. 这些信息使用了物理地址 0x0-0x9000 共 36 KB 的内存空间. 在汇编代码中, 我们对内核页表进行简单的设置, 暂时将线性地址 0x0 开始的 4MB 空间和线性地址 0xC0000000 开始的 4MB 空间都映射到物理地址 0x0 开始的内存区域内, 之后开启分页.

内核的初始堆栈静态的定义在 `kernel/sched.c` 文件中, 大小为 1 个页, 将栈底地址读入 `esp`  寄存器后, 跳转到 C 语言入口函数执行.

## 内核初始化 `kern_entry()`

内核的 C 语言入口函数位于 `init/entry.c` 文件中. 在该函数主要完成全局描述符表、中段描述符表、串口、时钟、内存和调度相关的初始化.

### 初始化全局描述符表 `setup_gdt()`

该函数定义在 `init/gdt.c` 文件中. 参考在 linux 中的设置, 内核虽然开启分段, 但并不实际使用分段, 而是将所有段的基址都设置为 0x0, 长度设置为 4GB.

### 初始化中断描述符表 `setup_idt()`

该函数定义在 `init/idt.c` 文件中. 函数中需要首先进行中断控制器的硬件初始化, 这里使用两片级联的 8259A 芯片进行中断控制, 对其进行初始化本质上只需要向有关的寄存器中依次写入相应的值即可.

完成硬件初始化后, 设置中断描述符表, 该表中包含 256 个表项, 每个表项中存放一个函数指针, 指向相应的中断描述符(中断服务例程, ISR). 其中 0-31 号为内部异常处理, 32 号之后为外部中断处理. 在 `kernel/asm/isr.s` 文件中以汇编宏的形式定义了多个中断描述符, 在系统初始化时, 将这些中断描述符填入对应的中断描述符表项中. 中断处理在当前线程的栈中进行, 其流程如下:

1. 硬件自动将 `cs`, `eip`, `eflags` 等寄存器压入栈中
2. 关中断
3. 将中断号和通用寄存器的值压入栈中
4. 将 `esp` 寄存器的值压入栈中, 作为之后中断处理函数的参数
5. 调用中断处理函数, 这个函数通过栈顶指针访问线程栈中的内容, 并对不同的中断作出相应的处理
6. 将压入栈中的内容清空
7. 开中断, 中断返回

中断处理函数表定义在 `kernel/isr.c` 文件中. 要使中断服务真正生效, 必须编写并设置好相应的中断处理函数. 内核提供了一个函数 `register_intr_handler()` 进行中断处理函数的注册.

### 串口初始化 `uart_init()`

该函数定义在 `drivers/uart.c` 文件中. 在对串口进行初始化时, 首先设置串口控制块, 之后对硬件进行设置, 同样是采用寄存器编程的形式来设置波特率、数据位长度等, 并开启中断使能. 最后将串口中断的处理函数注册到 36 号中断上.

### 时钟初始化 `clk_init()`

该函数定义在 `drivers/clock.c` 文件中. 时钟初始化时主要是进行分频的设置, 完成后将时钟中断的处理函数注册到 32 号中断上即可.

### 内存初始化 `mm_init()`

该函数定义在 `mm/memory.c` 文件中. 在这个函数中首先根据链接脚本提供的段地址信息, 完成内核页表的设置, 将线性地址 0xC0000000 开始的 32 MB 空间映射到物理内存 0x0 开始的区域. 并将 `.ro_data` 段所在的页设置为只读, 其他段设置为可读写. 之后将剩余的线性地址空间全部设置为无效.

之后对页框管理表进行初始化, 该表中每个表项对应一个页框, 保存了与该页框相关的一些信息. 接着进行伙伴系统的初始化, 在内核已使用的内存区域之后的内存空间都通过伙伴系统来进行管理, 伙伴系统对这些页框进行初始化, 并将其插入相应大小的伙伴链表中. 最后, 将缺页异常的处理函数注册到 14 号中断上.

### 调度初始化 `sched_init()`

该函数定义在 `kernel/sched.c` 文件中. 在这个函数中首先初始化调度队列, 并初始化一个僵尸队列负责运行完成的任务的回收. 之后初始化 idle 任务(由正在运行的内核初始任务转变而来), 并将其加入就绪队列.
